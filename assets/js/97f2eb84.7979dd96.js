"use strict";(self.webpackChunkdoom_neovim_github_io=self.webpackChunkdoom_neovim_github_io||[]).push([[3258],{3905:(e,n,o)=>{o.d(n,{Zo:()=>d,kt:()=>p});var t=o(7294);function a(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function i(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,t)}return o}function l(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?i(Object(o),!0).forEach((function(n){a(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function r(e,n){if(null==e)return{};var o,t,a=function(e,n){if(null==e)return{};var o,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)o=i[t],n.indexOf(o)>=0||(a[o]=e[o]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)o=i[t],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var m=t.createContext({}),s=function(e){var n=t.useContext(m),o=n;return e&&(o="function"==typeof e?e(n):l(l({},n),e)),o},d=function(e){var n=s(e.components);return t.createElement(m.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var o=e.components,a=e.mdxType,i=e.originalType,m=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),c=s(o),p=a,f=c["".concat(m,".").concat(p)]||c[p]||u[p]||i;return o?t.createElement(f,l(l({ref:n},d),{},{components:o})):t.createElement(f,l({ref:n},d))}));function p(e,n){var o=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=o.length,l=new Array(i);l[0]=c;var r={};for(var m in n)hasOwnProperty.call(n,m)&&(r[m]=n[m]);r.originalType=e,r.mdxType="string"==typeof e?e:a,l[1]=r;for(var s=2;s<i;s++)l[s]=o[s];return t.createElement.apply(null,l)}return t.createElement.apply(null,o)}c.displayName="MDXCreateElement"},6526:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>s});var t=o(7462),a=(o(7294),o(3905));const i={custom_edit_url:"https://github.com/doom-neovim/doom-nvim/blob/main/lua/doom/core/modules/init.lua"},l="Modules Spec",r={unversionedId:"modules/module-spec",id:"modules/module-spec",title:"Modules Spec",description:"This guide outlines the API and implementation details for doom modules.",source:"@site/docs/modules/module-spec.md",sourceDirName:"modules",slug:"/modules/module-spec",permalink:"/docs/modules/module-spec",draft:!1,editUrl:"https://github.com/doom-neovim/doom-nvim/blob/main/lua/doom/core/modules/init.lua",tags:[],version:"current",frontMatter:{custom_edit_url:"https://github.com/doom-neovim/doom-nvim/blob/main/lua/doom/core/modules/init.lua"},sidebar:"tutorialSidebar",previous:{title:"Building your own doom module",permalink:"/docs/modules/building-custom-module"},next:{title:"Code annotations",permalink:"/docs/modules/features/annotations"}},m={},s=[{value:"How modules are loaded",id:"how-modules-are-loaded",level:2},{value:"API Specification of a module",id:"api-specification-of-a-module",level:2}],d={toc:s};function u(e){let{components:n,...o}=e;return(0,a.kt)("wrapper",(0,t.Z)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"modules-spec"},"Modules Spec"),(0,a.kt)("p",null,"This guide outlines the API and implementation details for doom modules."),(0,a.kt)("h2",{id:"how-modules-are-loaded"},"How modules are loaded"),(0,a.kt)("p",null,"Doom-nvim will read your ",(0,a.kt)("inlineCode",{parentName:"p"},"modules.lua")," file and use it to determin which\nmodules to load upon starting up.  It will then use the table key and module\nsttring to dynamically load from the disk.  In the following example doom-nvim\nwill try to load from ",(0,a.kt)("inlineCode",{parentName:"p"},"lua/user/modules/features/my_module/init.lua")," and\nthen fall back to ",(0,a.kt)("inlineCode",{parentName:"p"},"lua/doom/modules/features/my_module/init.lua"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'--modules.lua\nreturn {\n  features = {\n    "my_module",\n  }\n}\n')),(0,a.kt)("h2",{id:"api-specification-of-a-module"},"API Specification of a module"),(0,a.kt)("p",null,"Modules are simply lua tables that define a number of fields used by the\ndoom nvim framework."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local DoomModule = require("doom.modules").DoomModule\n\nlocal example_module = DoomModule.new("example_module")\n\n-- Settings are a place to store configuration options for the module\n-- There is no specific format it must follow but best practice is to\n-- put tables that are passed to plugins into their own table.\nexample_module.settings = {\n  -- Module authors should supply general settings in the root of the\n  -- settings table.\n  add_auto_commands = false,\n  add_commands = false,\n  -- This table will be passed directly into the setup function\n  -- of a plugin.  It\'s best practice to store all of this config\n  -- under its own key.\n  example_plugin_config = {\n    keymaps = false,\n  }\n}\n\n-- Stores the packer.nvim config for all of the plugin dependencies\nexample_module.packages = {\n  ["example-plugin.nvim"] = { -- Use the repository name as the key\n    "GithubUser/example-plugin.nvim",\n    commit = "..." -- We like to pin plugins to commits to avoid issues upgrading.\n    -- the contents of this table is the same as the `use` function\n    -- of `packer.nvim`.\n  }\n}\n\n-- Stores config functions for packer dependencies\nexample_module.configs = {\n  -- key matches `example.packages` entry\n  ["example-plugin.nvim"] = function()\n    -- Consumes `example.settings.example_plugin_config` and uses it to\n    -- configure the plugin.\n    require(\'example-plugin\').setup( doom.features.example_module.settings.example_plugin_config )\n    -- \u26a0\ufe0f  Due to the way packer lazy loading works you can\'t access\n    -- `example_module` directly from this scope.  You have to access it\n    -- via the doom global illustrated above (doom.features.example_module).\n  end\n}\n\n-- Keybinds are defined using a modified nest.nvim table syntax.\nexample_module.binds = {\n  { \'<leader>e\', name = \'+example\', {\n    { \'e\', function() print(\'Example keybind\') end, name = "Print message" }\n  }}\n  { \'<leader>ff\', \'<cmd>:Telescope find_files<CR>\', name = \'Find files\'} -- `name = "..."` For `whichkey` and `mapper` integrations\n  { \'<leader>cc\', function() print(\'custom command\') end, name = \'Find files\' }, -- Can trigger either a `<cmd>` string or a function\n}\n\n-- You can create conditional keybinds (i.e. if a setting is true or if another\n-- module is enabled) by defining the `binds` field as a function that returns\n-- the same schema.\nexample_module.binds = function()\n  local binds = { ... }\n  if doom.features.other_module then\n    table.insert(binds, {\n      \'<leader>ff\', function() print(\'this is a conditional keybind\') end, name = \'My conditional keybind\'\n    })\n  end\n  return binds\nend\n\n-- Autocmds are defined as a table with the following syntax\n-- { "event", "aupat", "command or function" }\n-- Example\nexample_module.autocmds = {\n  { "BufWinEnter", "*.js", function() print("I\'m in a javascript file now") end }\n  { "BufWinEnter", "*.js", "<CMD>echo \'Im a javascript file now\'<CR>" }\n}\n-- Similarly, autocmds can be conditional using a function\nexample_module.autocmds = function()\n  local autocmds = {}\n  if example_module.settings.add_auto_commands then\n    table.insert(autocmds, { "BufWinEnter", "*.js", function() print("I\'m in a javascript file now") end })\n  end\n  return autocmds\nend\n\n-- Autocmds are defined as a table with the following syntax\n-- { "Command", "command or function"}\n-- Example\nexample_module.cmds = {\n  -- Binds :MyCommand to print "my command!"\n  {"MyCommand", function() print(\'my command!\') },\n  -- Binds :MyOtherCommand to print "my command!"\n  {"MyOtherCommand", "<CMD>echo \'my other command\'<CR>" }\n\n\nreturn example_module\n')),(0,a.kt)("p",null,"@class DoomPackageEntry\n@field ","[1]",' string Source of package/plugin i.e "neovim/nvim-lspconfig".\n@field on_pre_config function(callback:function)nil Add a callback to execute a function once the packages loads but before doom configures the package.\n@field on_post_config function(callback:function)nil Add a callback to execute a function once the packages loads, after doom configures the package.'),(0,a.kt)("p",null,"@alias DoomPackages table<string, DoomPackageEntry>"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"                          `DoomPackages.new`()\n")),(0,a.kt)("p",null,"Creates a new metatable for doom packages.\nDoomPackages"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"                `DoomPackages.new_from_config`({table})\n")),(0,a.kt)("p",null,"Creates a new DoomPackages object and populates it with data from the modules spec\n{table} DoomPackages\nDoomPackages"),(0,a.kt)("p",null,"@class DoomModule\n@field name string Name of the module\n@field settings table|nil A custom table containing settings for\n@field packages DoomPackages|nil A table of plugins / packages that this module depends upon\n@field configs table|nil A table of configs relating to the packages, will be automatically passed into packer as the config function.\n@field binds table|function():table|nil A table of keybinds or a function that returns a table of keybinds\n@field cmds table|function():table|nil A Table of commands or a function that returns a table of commands\n@field autocmds table|function():table|nil A table of auto-commands or a function that returns a table of auto-commands"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"                        `DoomModule.new`({name})\n")),(0,a.kt)("p",null,"Create's a new instance of a DoomModule.\n{name} ",(0,a.kt)("inlineCode",{parentName:"p"},"(string)")," name of the module\nDoomModule"))}u.isMDXComponent=!0}}]);