"use strict";(self.webpackChunkdoom_neovim_github_io=self.webpackChunkdoom_neovim_github_io||[]).push([[788],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>p});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=o.createContext({}),l=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):u(u({},n),e)),t},d=function(e){var n=l(e.components);return o.createElement(c.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=l(t),p=a,h=m["".concat(c,".").concat(p)]||m[p]||s[p]||r;return t?o.createElement(h,u(u({ref:n},d),{},{components:t})):o.createElement(h,u({ref:n},d))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,u=new Array(r);u[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,u[1]=i;for(var l=2;l<r;l++)u[l]=t[l];return o.createElement.apply(null,u)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7655:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>u,default:()=>s,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var o=t(7462),a=(t(7294),t(3905));const r={},u="Building your own doom module",i={unversionedId:"modules/building-custom-module",id:"modules/building-custom-module",title:"Building your own doom module",description:"Overview",source:"@site/docs/modules/building-custom-module.md",sourceDirName:"modules",slug:"/modules/building-custom-module",permalink:"/docs/modules/building-custom-module",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"All modules",permalink:"/docs/modules/all-modules"},next:{title:"Modules Spec",permalink:"/docs/modules/module-spec"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Guide",id:"guide",level:2},{value:"1. Setting up",id:"1-setting-up",level:3},{value:"2. Adding autocommands",id:"2-adding-autocommands",level:3},{value:"3. Enabling and testing your module",id:"3-enabling-and-testing-your-module",level:3},{value:"4. Adding the character counter",id:"4-adding-the-character-counter",level:3},{value:"5. Adding commands to get and reset the count",id:"5-adding-commands-to-get-and-reset-the-count",level:3},{value:"6. Adding keybinds",id:"6-adding-keybinds",level:3},{value:"7. Adding and lazyloading a plugin",id:"7-adding-and-lazyloading-a-plugin",level:3},{value:"8. Exposing settings to the user",id:"8-exposing-settings-to-the-user",level:3},{value:"9. Contributing your module upstream",id:"9-contributing-your-module-upstream",level:3},{value:"10. You&#39;re done!  Final output",id:"10-youre-done--final-output",level:3}],d={toc:l};function s(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"building-your-own-doom-module"},"Building your own doom module"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"A doom module is a stand-alone collection of packages, autocommands, commands,\nkeybinds that adds capabilities to doom-nvim.  They are implemented using a\nstandardised format documented ",(0,a.kt)("a",{parentName:"p",href:"./module-spec"},"here")," and consumed by the\ndoom-nvim framework."),(0,a.kt)("p",null,"This guide shows you how to implement a new doom module that counts the number of\ncharacters that you've typed."),(0,a.kt)("p",null,"This module will:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use autocommands to count the number of chars in a buffer when you enter insert mode vs when you leave insert mode"),(0,a.kt)("li",{parentName:"ul"},"Add it to an accumulated sum"),(0,a.kt)("li",{parentName:"ul"},"Provide keybinds + commands to restart or display total count"),(0,a.kt)("li",{parentName:"ul"},"Use a plugin to display the results in a popup window"),(0,a.kt)("li",{parentName:"ul"},"Include some settings to change the displayed output")),(0,a.kt)("h2",{id:"guide"},"Guide"),(0,a.kt)("h3",{id:"1-setting-up"},"1. Setting up"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Because modules are implemented as folders with an ",(0,a.kt)("inlineCode",{parentName:"p"},"init.lua")," inside, they must be named after valid folder names.\nBest practices are:"),(0,a.kt)("ul",{parentName:"blockquote"},(0,a.kt)("li",{parentName:"ul"},"Seperate words with an underscore, this is so the plugin can be represented as a lua variable"),(0,a.kt)("li",{parentName:"ul"},"Name the module after the functionality rather than the plugin it uses."))),(0,a.kt)("p",null,"For our example of adding char counting plugin I will create a folder called ",(0,a.kt)("inlineCode",{parentName:"p"},"lua/user/modules/features/char_counter/"),"\nand create a new ",(0,a.kt)("inlineCode",{parentName:"p"},"init.lua")," inside of it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- lua/user/modules/features/char_counter/init.lua\nlocal DoomModule = require("doom.modules").DoomModule\nlocal char_counter = DoomModule.new("char_counter")\n\nreturn char_counter\n')),(0,a.kt)("h3",{id:"2-adding-autocommands"},"2. Adding autocommands"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Autocommands are set using the ",(0,a.kt)("inlineCode",{parentName:"p"},"module_name.autocmds")," field.  And follow the structure of"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'module_name.autocmds = {\n  { "{event}", "{aupat}", "command or function" }\n}\n'))),(0,a.kt)("p",null,"For our example we need to hook into the ",(0,a.kt)("a",{parentName:"p",href:"https://neovim.io/doc/user/autocmd.html#InsertEnter"},"InsertEnter"),"\nand ",(0,a.kt)("a",{parentName:"p",href:"https://neovim.io/doc/user/autocmd.html#InsertLeave"},"InsertLeave")," auto commands."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- lua/user/modules/features/char_counter/init.lua\nchar_counter.autocmds = {\n  { "InsertEnter", "*", function ()\n    print(\'Entered insert mode\')\n  end},\n  { "InsertLeave", "*", function ()\n    print(\'Exited insert mode\')\n  end},\n}\n')),(0,a.kt)("h3",{id:"3-enabling-and-testing-your-module"},"3. Enabling and testing your module"),(0,a.kt)("p",null,"Now you can enable the module in ",(0,a.kt)("inlineCode",{parentName:"p"},"modules.lua"),"!  Once enabled, restart your\ndoom-nvim instance and check ",(0,a.kt)("inlineCode",{parentName:"p"},":messages")," to see if it's printing correctly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"-- modules.lua\nreturn {\n  features = {\n    'char_counter',\n  },\n}\n")),(0,a.kt)("h3",{id:"4-adding-the-character-counter"},"4. Adding the character counter"),(0,a.kt)("p",null,"Because modules are just tables, you can add any properties or functions that\nyou need to the module table. To implement the character counter we will add a\nfew fields to the module table.  Unless you want users to access these fields we\nrecommend prefixing them with an underscore."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"A function that gets the character count of a buffer."),(0,a.kt)("li",{parentName:"ol"},"A field to store the character count when we enter insert mode."),(0,a.kt)("li",{parentName:"ol"},"A field to store the accumulated count when we exit insert mode.")),(0,a.kt)("p",null,"We will also check if the ",(0,a.kt)("a",{parentName:"p",href:"https://neovim.io/doc/user/options.html#'buftype'"},(0,a.kt)("inlineCode",{parentName:"a"},"buftype"))," is empty, this\nmeans we wont count other interactive buffers like terminals, prompts or quick fix lists."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- lua/user/modules/features/char_counter/init.lua\n\nlocal char_counter = {}\n\nchar_counter._insert_enter_char_count = nil\nchar_counter._accumulated_difference = 0\nchar_counter._get_current_buffer_char_count = function()\n  local lines = vim.api.nvim_buf_line_count(0)\n  local chars = 0\n  for _, line in ipairs(vim.api.nvim_buf_get_lines(0, 0, lines, false)) do\n    chars = chars + #line\n  end\n  return chars\nend\n\nchar_counter.autocmds = {\n  { "InsertEnter", "*", function ()\n    -- Only operate on normal file buffers\n    print(("buftype: %s"):format(vim.bo.buftype))\n    if vim.bo.buftype == "" then\n      -- Store current char count\n      char_counter._insert_enter_char_count = char_counter._get_current_buffer_char_count()\n    end\n  end},\n  { "InsertLeave", "*", function ()\n    -- Only operate on normal file buffers\n    if vim.bo.buftype == "" and char_counter._insert_enter_char_count then\n      -- Find the amount of chars added or removed\n      local new_count = char_counter._get_current_buffer_char_count()\n      local diff = new_count - char_counter._insert_enter_char_count\n      print(new_count, diff)\n      -- Add the difference to the accumulated total\n      char_counter._accumulated_difference = char_counter._accumulated_difference + diff\n      print((\'Accumulated difference %s\'):format(char_counter._accumulated_difference))\n    end\n  end},\n}\n\nreturn char_counter\n')),(0,a.kt)("h3",{id:"5-adding-commands-to-get-and-reset-the-count"},"5. Adding commands to get and reset the count"),(0,a.kt)("p",null,"Using the ",(0,a.kt)("inlineCode",{parentName:"p"},"module.cmds")," property we can define and expose vim commands to the user.  Here we will define a\n",(0,a.kt)("inlineCode",{parentName:"p"},":CountPrint")," and ",(0,a.kt)("inlineCode",{parentName:"p"},":CountReset")," command."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- lua/user/modules/features/char_counter/init.lua\n\nchar_counter.cmds = {\n  { "CountPrint", function ()\n    local msg = ("char_counter: You have typed %s characters since I started counting."):format(char_counter._accumulated_difference)\n    vim.notify(msg, "info")\n  end},\n  { "CountReset", function ()\n    char_counter._accumulated_difference = 0\n    vim.notify("char_counter: Reset count!", "info")\n  end}\n}\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),": Instead of using a function you can also provide a string that will be executed using ",(0,a.kt)("inlineCode",{parentName:"p"},"vim.cmd"))),(0,a.kt)("p",null,"Now restart doom nvim and run ",(0,a.kt)("inlineCode",{parentName:"p"},":CountPrint")," and ",(0,a.kt)("inlineCode",{parentName:"p"},":CountReset")," to test it out."),(0,a.kt)("h3",{id:"6-adding-keybinds"},"6. Adding keybinds"),(0,a.kt)("p",null,"Keybinds are provided using the ",(0,a.kt)("inlineCode",{parentName:"p"},"module.binds")," field.  We use a modified ",(0,a.kt)("a",{parentName:"p",href:"../keymaps"},"nest.nvim")," config that integrates with whichkey and nvim-mapper. You can read more about it ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/connorgmeehan/nest.nvim/tree/integrations-api#quickstart-guide"},"here")," but generally you should provide the ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," field for all entries so it displays in whichkey."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"-- lua/user/modules/features/char_counter/init.lua\n\nchar_counter.binds = {\n  { '<leader>i', name = '+info', { -- Adds a new `whichkey` folder called `+info`\n    { 'c', '<cmd>:CountPrint<CR>', name = 'Print new chars' }, -- Binds `:CountPrint` to `<leader>ic`\n    { 'r', '<cmd>:CountReset<CR>', name = 'Reset char count' } -- Binds `:CountPrint` to `<leader>ic`\n  } }\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),": Instead of a cmd you can also provide a lua function that will be executed when the keybind is triggered.")),(0,a.kt)("h3",{id:"7-adding-and-lazyloading-a-plugin"},"7. Adding and lazyloading a plugin"),(0,a.kt)("p",null,"Plugins are added using the ",(0,a.kt)("inlineCode",{parentName:"p"},"module.packages")," field and are configured using the ",(0,a.kt)("inlineCode",{parentName:"p"},"module.configs")," field.\nWe use the repository name as a key to connect the plugin to its config function.\nThe API for ",(0,a.kt)("inlineCode",{parentName:"p"},"module.packages")," is passed to Packer nvim's use function. ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/wbthomason/packer.nvim#specifying-plugins"},"DOCS")),(0,a.kt)("p",null,"In this example I will add ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/MunifTanjim/nui.nvim"},"nui.nvim")," to display the results in a popup when\nthe user uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"CountPrint")," command."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- lua/user/modules/features/char_counter/init.lua\n\n-- Add these two fields to `char_counter` at the top of the file.\nchar_counter.packages = {\n  ["nui.nvim"] = {\n    "MunifTanjim/nui.nvim",\n    cmd = { "CountPrint" } -- Here, nui.nvim wont be loaded until user does the `<leader>ic` or `:CountPrint` command.\n  }\n}\n\nchar_counter.configs = {\n  ["nui.nvim"] = function()\n    -- Log when nui loads so we can check that it\'s being lazy loaded correctly\n    vim.notify("char_counter: nui.nvim loaded", "info")\n\n    -- If your plugin requires a `.setup({ ... config ... })` function, this is where you\'d execute it.\n\n    -- WARNING: Because of how Packer compiles plugin configs, this function does not have direct access to `char_counter` table.\n    -- The only way to access the `char_counter` object is via `doom.features.char_counter`\n  end\n}\n\n-- Modify `char_counter.cmds`\n\nchar_counter.cmds = {\n  { "CountPrint", function ()\n    -- We can ensure that nui has loaded due to the `cmd = { "CountPrint" }` in the plugin\'s config\n    local Popup = require(\'nui.popup\')\n\n    local popup = Popup({\n      position = \'50%\',\n      size = {\n        width = 80,\n        height = 40,\n      },\n      border = {\n        padding = {\n          top = 2,\n          bottom = 2,\n          left = 3,\n          right = 3,\n        },\n      },\n      style = "rounded",\n      enter = true,\n      buf_options = {\n        modifiable = true,\n        readonly = true,\n      }\n    })\n    popup:mount()\n    popup:map("n", "<esc>", function() popup:unmount() end)\n\n    local msg = ("char_counter: You have typed %s characters since I started counting."):format(char_counter._accumulated_difference)\n    vim.api.nvim_buf_set_lines(popup.bufnr, 0, 1, false, { msg })\n  end},\n  { "CountReset", function ()\n    char_counter._accumulated_difference = 0\n    vim.notify("char_counter: Reset count!", "info")\n  end}\n}\n')),(0,a.kt)("h3",{id:"8-exposing-settings-to-the-user"},"8. Exposing settings to the user"),(0,a.kt)("p",null,"In order to keep doom-nvim flexible, it's best practice to expose settings for the module.  A common practice is just to expose the entire config\nobject.  This will allow users to tweak the config in their ",(0,a.kt)("inlineCode",{parentName:"p"},"config.lua")," file without replacing and rewriting all of the logic for a small change."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- lua/user/modules/features/char_counter/init.lua\n\n-- Copy the settings that are passed to the `Popup` function, place them in `char_counter.settings.popup`\nchar_counter.settings = {\n  popup = {\n    position = \'50%\',\n    size = {\n      width = 80,\n      height = 40,\n    },\n    border = {\n      padding = {\n        top = 2,\n        bottom = 2,\n        left = 3,\n        right = 3,\n      },\n    },\n    style = "rounded",\n    enter = true,\n    buf_options = {\n      modifiable = true,\n      readonly = true,\n    }\n  }\n}\n\n-- Modify the Popup function\nchar_counter.cmds = {\n  { "CountPrint", function ()\n    local Popup = require(\'nui.popup\')\n\n    local popup = Popup(char_counter.settings.popup) -- Configured via the `settings.popup` field.\n\n    popup:mount()\n    popup:map("n", "<esc>", function() popup:unmount() end)\n\n    local msg = ("char_counter: You have typed %s characters since I started counting."):format(char_counter._accumulated_difference)\n    vim.api.nvim_buf_set_lines(popup.bufnr, 0, 1, false, { msg })\n  end},\n  { "CountReset", function ()\n    char_counter._accumulated_difference = 0\n    vim.notify("char_counter: Reset count!", "info")\n  end}\n}\n')),(0,a.kt)("h3",{id:"9-contributing-your-module-upstream"},"9. Contributing your module upstream"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Builtin modules are loaded from the ",(0,a.kt)("inlineCode",{parentName:"p"},"lua/doom/modules/")," folder.  Within this folder there is a ",(0,a.kt)("inlineCode",{parentName:"p"},"features/"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"langs/")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"core/")," directory."),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'return {\n  features = {\n    "lsp" -- Maps to `lua/doom/modules/features/lsp/`,\n  },\n  langs = {\n    "lua" -- Maps to `lua/doom/modules/langs/lua/`\n  }\n}\n'))),(0,a.kt)("p",null,"If you would like to contribute your module, just move it from ",(0,a.kt)("inlineCode",{parentName:"p"},"lua/user/modules/<module_name>")," to\n",(0,a.kt)("inlineCode",{parentName:"p"},"lua/user/modules/<langs|features>/<module_name>")," and create a PR in accordance with our ",(0,a.kt)("a",{parentName:"p",href:"../contributing"},"Contributing Guidelines"),"."),(0,a.kt)("h3",{id:"10-youre-done--final-output"},"10. You're done!  Final output"),(0,a.kt)("p",null,"If you'd just like to look at the end result, or if you're comparing why your implementation didn't work, here is the final working output."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'-- lua/user/modules/features/char_counter/init.lua\nlocal char_counter = {}\n\nchar_counter.settings = {\n  popup = {\n    position = \'50%\',\n    size = {\n      width = 80,\n      height = 40,\n    },\n    border = {\n      padding = {\n        top = 2,\n        bottom = 2,\n        left = 3,\n        right = 3,\n      },\n    },\n    style = "rounded",\n    enter = true,\n    buf_options = {\n      modifiable = true,\n      readonly = true,\n    }\n  }\n}\n\nchar_counter.packages = {\n  ["nui.nvim"] = {\n    "MunifTanjim/nui.nvim",\n    cmd = { "CountPrint" }\n  }\n}\n\nchar_counter.configs = {\n  ["nui.nvim"] = function()\n    vim.notify("char_counter: nui.nvim loaded", "info")\n  end\n}\n\nchar_counter._insert_enter_char_count = nil\nchar_counter._accumulated_difference = 0\nchar_counter._get_current_buffer_char_count = function()\n  local lines = vim.api.nvim_buf_line_count(0)\n  local chars = 0\n  for _, line in ipairs(vim.api.nvim_buf_get_lines(0, 0, lines, false)) do\n    chars = chars + #line\n  end\n  return chars\nend\n\nchar_counter.autocmds = {\n  { "InsertEnter", "*", function ()\n    -- Only operate on normal file buffers\n    print(("buftype: %s"):format(vim.bo.buftype))\n    if vim.bo.buftype == "" then\n      -- Store current char count\n      char_counter._insert_enter_char_count = char_counter._get_current_buffer_char_count()\n    end\n  end},\n  { "InsertLeave", "*", function ()\n    -- Only operate on normal file buffers\n    if vim.bo.buftype == "" and char_counter._insert_enter_char_count then\n      -- Find the amount of chars added or removed\n      local new_count = char_counter._get_current_buffer_char_count()\n      local diff = new_count - char_counter._insert_enter_char_count\n      print(new_count, diff)\n      -- Add the difference to the accumulated total\n      char_counter._accumulated_difference = char_counter._accumulated_difference + diff\n      print((\'Accumulated difference %s\'):format(char_counter._accumulated_difference))\n    end\n  end},\n}\n\nchar_counter.cmds = {\n  { "CountPrint", function ()\n    local Popup = require(\'nui.popup\')\n    local popup = Popup(char_counter.settings.popup)\n    popup:mount()\n    popup:map("n", "<esc>", function() popup:unmount() end)\n\n    local msg = ("char_counter: You have typed %s characters since I started counting."):format(char_counter._accumulated_difference)\n    vim.api.nvim_buf_set_lines(popup.bufnr, 0, 1, false, { msg })\n  end},\n  { "CountReset", function ()\n    char_counter._accumulated_difference = 0\n    vim.notify("char_counter: Reset count!", "info")\n  end}\n}\n\nchar_counter.binds = {\n  { \'<leader>i\', name = \'+info\', { -- Adds a new `whichkey` folder called `+info`\n    { \'c\', \'<cmd>:CountPrint<CR>\', name = \'Print new chars\' }, -- Binds `:CountPrint` to `<leader>ic`\n    { \'r\', \'<cmd>:CountReset<CR>\', name = \'Reset char count\' } -- Binds `:CountPrint` to `<leader>ic`\n  } }\n}\n\nreturn char_counter\n')))}s.isMDXComponent=!0}}]);